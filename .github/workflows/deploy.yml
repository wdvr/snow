name: Deploy to AWS

on:
  push:
    branches: [ main ]
    tags:
      - 'v*'  # Trigger prod deployment on version tags like v1.0.0
  pull_request:
    types: [labeled]  # Deploy dev when PR is labeled with 'deploy-dev'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod

env:
  PYTHON_VERSION: '3.12'
  PULUMI_STATE_BUCKET: snow-tracker-pulumi-state-us-west-2

jobs:
  # Determine which environment to deploy to
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      should_deploy: ${{ steps.set-env.outputs.should_deploy }}
    steps:
      - name: Set environment based on trigger
        id: set-env
        run: |
          # Manual workflow dispatch
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "Manual deployment to ${{ github.event.inputs.environment }}"

          # Version tag -> prod
          elif [ "${{ github.ref_type }}" = "tag" ]; then
            echo "environment=prod" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "Deploying to PROD from tag: ${{ github.ref_name }}"

          # Push to main -> staging (auto-deploy)
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "Deploying to STAGING from main branch"

          # PR labeled with 'deploy-dev' -> dev
          elif [ "${{ github.event_name }}" = "pull_request" ] && [ "${{ github.event.label.name }}" = "deploy-dev" ]; then
            echo "environment=dev" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
            echo "Deploying to DEV from PR #${{ github.event.pull_request.number }}"

          else
            echo "environment=none" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

  deploy:
    name: Deploy to ${{ needs.determine-environment.outputs.environment }}
    needs: determine-environment
    if: needs.determine-environment.outputs.should_deploy == 'true'
    runs-on: ubuntu-latest
    environment: ${{ needs.determine-environment.outputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Install uv
      uses: astral-sh/setup-uv@v5
      with:
        version: "latest"

    - name: Install Pulumi CLI
      run: |
        curl -fsSL https://get.pulumi.com | sh
        echo "$HOME/.pulumi/bin" >> $GITHUB_PATH

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: us-west-2

    - name: Install infrastructure dependencies with uv
      run: |
        cd infrastructure
        uv pip install --system -r requirements.txt

    - name: Set environment variables
      run: |
        echo "ENVIRONMENT=${{ needs.determine-environment.outputs.environment }}" >> $GITHUB_ENV
        echo "PULUMI_CONFIG_PASSPHRASE=${{ secrets.PULUMI_CONFIG_PASSPHRASE }}" >> $GITHUB_ENV

    # NOTE: Removed aggressive cleanup that was destroying all resources.
    # API Gateway URL now stays stable across deployments.
    # If you have orphaned resources, clean them up manually or use pulumi destroy.

    - name: Deploy infrastructure
      run: |
        cd infrastructure

        # Use S3 backend for state (falls back to local if bucket doesn't exist yet)
        if aws s3 ls "s3://${{ env.PULUMI_STATE_BUCKET }}" 2>/dev/null; then
          pulumi login s3://${{ env.PULUMI_STATE_BUCKET }}
        else
          echo "S3 state bucket not found, using local backend for bootstrap"
          pulumi login --local
        fi

        # Create or select stack
        pulumi stack select ${{ env.ENVIRONMENT }} || pulumi stack init ${{ env.ENVIRONMENT }}

        # Cancel any stale locks from previous failed runs
        pulumi cancel --yes 2>/dev/null || true

        # Set configuration
        pulumi config set aws:region us-west-2
        pulumi config set snow-tracker-infrastructure:env ${{ env.ENVIRONMENT }}
        pulumi config set snow-tracker-infrastructure:appName snow-tracker

        # Deploy - Pulumi will update existing resources in place
        pulumi up --yes --diff

    - name: Package Lambda functions with pip
      run: |
        cd backend
        mkdir -p dist
        # Use requirements-lambda.txt with Linux platform for Lambda compatibility
        pip install -q -r requirements-lambda.txt --target dist/ --platform manylinux2014_x86_64 --python-version 3.12 --only-binary :all:
        cp -r src/* dist/
        cd dist && zip -r ../lambda-package.zip . && cd ..

    - name: Upload Lambda package
      uses: actions/upload-artifact@v4
      with:
        name: lambda-package-${{ env.ENVIRONMENT }}
        path: backend/lambda-package.zip

    - name: Deploy Lambda code and configure
      run: |
        cd infrastructure

        # Upload Lambda package to S3 (required for packages > 50MB)
        S3_BUCKET="${{ env.PULUMI_STATE_BUCKET }}"
        S3_KEY="lambda-packages/${{ env.ENVIRONMENT }}/lambda-package-$(date +%Y%m%d%H%M%S).zip"
        echo "Uploading Lambda package to s3://$S3_BUCKET/$S3_KEY"
        aws s3 cp ../backend/lambda-package.zip "s3://$S3_BUCKET/$S3_KEY"

        # Deploy API Handler Lambda
        API_LAMBDA=$(pulumi stack output api_handler_lambda_name 2>/dev/null || echo "")
        if [ -n "$API_LAMBDA" ]; then
          echo "Deploying API handler Lambda: $API_LAMBDA"
          aws lambda update-function-code \
            --function-name "$API_LAMBDA" \
            --s3-bucket "$S3_BUCKET" \
            --s3-key "$S3_KEY" \
            --region us-west-2
          aws lambda wait function-updated --function-name "$API_LAMBDA" --region us-west-2
          echo "API handler Lambda updated"
        fi

        # Deploy Weather Processor Lambda
        WEATHER_LAMBDA=$(pulumi stack output weather_processor_lambda_name 2>/dev/null || echo "")
        if [ -n "$WEATHER_LAMBDA" ]; then
          echo "Deploying Weather processor Lambda: $WEATHER_LAMBDA"
          aws lambda update-function-code \
            --function-name "$WEATHER_LAMBDA" \
            --s3-bucket "$S3_BUCKET" \
            --s3-key "$S3_KEY" \
            --region us-west-2
          aws lambda wait function-updated --function-name "$WEATHER_LAMBDA" --region us-west-2

          # Update Weather Lambda environment variables with Weather API key
          aws lambda update-function-configuration \
            --function-name "$WEATHER_LAMBDA" \
            --environment "Variables={ENVIRONMENT=${{ env.ENVIRONMENT }},RESORTS_TABLE=snow-tracker-resorts-${{ env.ENVIRONMENT }},WEATHER_CONDITIONS_TABLE=snow-tracker-weather-conditions-${{ env.ENVIRONMENT }},AWS_REGION_NAME=us-west-2,WEATHER_API_KEY=${{ secrets.WEATHER_API_KEY }}}" \
            --region us-west-2
          # Wait for configuration update to complete before invoking
          aws lambda wait function-updated --function-name "$WEATHER_LAMBDA" --region us-west-2
          echo "Weather processor Lambda updated"
        fi

        echo "Lambda deployment complete"

    - name: Seed resort data (dev/staging only)
      if: env.ENVIRONMENT == 'dev' || env.ENVIRONMENT == 'staging'
      run: |
        cd backend
        uv pip install --system -r requirements.txt
        PYTHONPATH=src python scripts/seed_resorts.py --summary
        PYTHONPATH=src python scripts/seed_resorts.py
      env:
        RESORTS_TABLE: snow-tracker-resorts-${{ env.ENVIRONMENT }}
        AWS_DEFAULT_REGION: us-west-2

    - name: Invoke weather processor to fetch initial data
      run: |
        cd infrastructure
        WEATHER_LAMBDA=$(pulumi stack output weather_processor_lambda_name 2>/dev/null || echo "")

        if [ -n "$WEATHER_LAMBDA" ]; then
          echo "Invoking weather processor: $WEATHER_LAMBDA"
          aws lambda invoke \
            --function-name "$WEATHER_LAMBDA" \
            --region us-west-2 \
            --payload '{}' \
            /tmp/weather-response.json

          echo "Weather processor response:"
          cat /tmp/weather-response.json

          # Wait for CloudWatch logs to propagate
          echo "Waiting for CloudWatch logs to propagate..."
          sleep 10

          # Fetch recent CloudWatch logs to see any errors
          echo ""
          echo "=== Recent Lambda Logs ==="
          LOG_GROUP="/aws/lambda/$WEATHER_LAMBDA"

          # Get the most recent log stream
          LATEST_STREAM=$(aws logs describe-log-streams \
            --log-group-name "$LOG_GROUP" \
            --order-by LastEventTime \
            --descending \
            --limit 1 \
            --region us-west-2 \
            --query 'logStreams[0].logStreamName' \
            --output text 2>/dev/null || echo "")

          if [ -n "$LATEST_STREAM" ] && [ "$LATEST_STREAM" != "None" ]; then
            aws logs get-log-events \
              --log-group-name "$LOG_GROUP" \
              --log-stream-name "$LATEST_STREAM" \
              --limit 50 \
              --region us-west-2 \
              --query 'events[*].message' \
              --output text 2>/dev/null || echo "Could not fetch logs"
          else
            echo "No log streams found yet"
          fi
        else
          echo "Weather processor Lambda name not available"
        fi

    - name: Run smoke tests
      run: |
        # Wait for deployment to be ready
        sleep 30

        # Get API Gateway URL from Pulumi outputs
        cd infrastructure
        API_URL=$(pulumi stack output api_gateway_url 2>/dev/null || echo "")

        if [ -n "$API_URL" ]; then
          echo "Testing API at: $API_URL"

          # Test health endpoint
          curl -f "$API_URL/health" || echo "Health check failed"

          # Test resorts endpoint
          curl -f "$API_URL/api/v1/resorts" || echo "Resorts endpoint failed"
        else
          echo "API URL not available, skipping smoke tests"
        fi

    - name: Deployment Summary
      run: |
        echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Environment**: ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Region**: us-west-2" >> $GITHUB_STEP_SUMMARY
        echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        if [ "${{ github.ref_type }}" = "tag" ]; then
          echo "- **Tag**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        fi
        echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Deployed at**: $(date -u)" >> $GITHUB_STEP_SUMMARY

        cd infrastructure
        API_URL=$(pulumi stack output api_gateway_url 2>/dev/null || echo "Not available")
        echo "- **API URL**: $API_URL" >> $GITHUB_STEP_SUMMARY

        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Deployment Strategy" >> $GITHUB_STEP_SUMMARY
        echo "| Environment | Trigger |" >> $GITHUB_STEP_SUMMARY
        echo "|-------------|---------|" >> $GITHUB_STEP_SUMMARY
        echo "| dev | Manual dispatch, PR label 'deploy-dev', or localhost |" >> $GITHUB_STEP_SUMMARY
        echo "| staging | Auto-deploy on merge to main |" >> $GITHUB_STEP_SUMMARY
        echo "| prod | Manual dispatch or git tag (v*) |" >> $GITHUB_STEP_SUMMARY
